#!/usr/bin/env python

""" A wrapper script for simulating RNA editing datasets with InSilicoSeq """

import subprocess
import pathlib
import os
import argparse
import gzip
from Bio import SeqIO

L: int = 150    # Read length under the NovaSeq model assumed in the InSilicoSeq simulations


def fasta_length(file: str) -> int:
    """
    Obtain the total length of all the records in a FASTA file
    """
    G: int = 0

    for record in SeqIO.parse(file, "fasta"):
        G += len(record)

    return G


def iss_generate(
        input_files: list[pathlib.Path],
        output_dir: pathlib.Path,
        mode: str,
        tag: str,
        n_reads: int,
        seed: int,
        cpus: int
        ) -> None:
    """
    Call InSilicoSeq to perform read simulations.
    """

    assert (mode == "edited") or (mode == "unedited")

    iss_command: list[str] = ["iss", "generate"]
    iss_command += ["--model", "NovaSeq"]
    iss_command += ["--n_reads", str(n_reads)]

    # Settings for input "genomes"
    iss_command.append("--genomes")
    iss_command += input_files
    iss_command += ["--abundance", "uniform"]    # Uniform sampling means equal expression of haplotypes

    # Output
    output_prefix: str = str(output_dir) + '/' + tag + '_' + mode
    iss_command += ["--output", output_prefix]
    
    # Misc
    iss_command += ["--seed", str(seed)]
    iss_command += ["--cpus", str(cpus)]
    
    subprocess.run(iss_command)

    return None


def add_label_to_identifier(identifier: str, label: str) -> str:
    """
    Add a label after to a FASTQ identifier generated by InSilicoSeq.

    Example:
        all_label_to_identifier("21_0_0/2", "edited") -> "@21_edited_0_0/2"

    This label can be used to maintain identifier uniqueness when combining FASTQ files from InSilicoSeq.
    """
    parts: list[str] = identifier.split('_')
    new_indentifier: str = '_'.join([parts[0], label, *parts[1:]])

    return new_indentifier


def combine_reads(reads_dir: pathlib.Path, tag: str) -> None:
    """
    Combine the unedited and edited reads (R1 and R2) from InSilicoSeq simulations into a single compressed FASTQ file.
    """
    output_prefix: str = str(reads_dir) + '/' + tag + '_'
    output_postfix: str = ".fastq.gzip"

    for rtag in ["R1", "R2"]:
        with gzip.open(output_prefix + rtag + output_postfix, "wt") as outstream:
            for rna_type in ["unedited", "edited"]:
                input_file_list = reads_dir.glob(f"*_{rna_type}_{rtag}.fastq")

                for input_file in input_file_list:
                    with open(input_file) as instream:
                        for i, line in enumerate(instream):
                            if i % 4 == 0:
                                assert line[0] == '@'
                                outstream.write(add_label_to_identifier(line, rna_type))
                            else:
                                outstream.write(line)

    return None


if __name__ == "__main__":
    parser: argparse.ArgumentParser = argparse.ArgumentParser(
        description="Run InSilicoSeq on a set of edited and unedited transcriptome sequence files"
    )
    parser.add_argument("-u", "--useq", nargs='+', help="FASTQ files with unedited sequences", required=True)
    parser.add_argument("-e", "--eseq", nargs='+', help="FASTQ files with edited sequences", required=True)
    parser.add_argument("-t", "--tag", type=str, default="")
    parser.add_argument("-c", "--coverage", type=int, default=100, help="Desired coverage \"times x\" (default=100)")
    parser.add_argument("-p", "--p_edited_reads", type=float, help="Proportion of edited reads", required=True)
    parser.add_argument("-o", "--output_dir", type=str, default=str(pathlib.Path(os.getcwd())), help="Output directory")
    parser.add_argument("-j", "--threads", type=int, default=1, help="Number of threads to use in InSilicoSeq (default=1)")
    parser.add_argument("-s", "--seed", type=int, default=1, help="Seed number for unedited simulations, increased by 1 for edited simulations (default=1)")

    args: argparse.Namespace = parser.parse_args()

    # Compute "genome" length G from the median total length of all the input sequence files
    G_list = [fasta_length(file) for file in args.useq]
    G_list += [fasta_length(file) for file in args.eseq]
    G_list.sort()
    G = G_list[len(G_list) // 2]

    # Compute number of reads N based on the desired coverage
    N = int(round(args.coverage * G / L))
    N_edited = int(round(args.p_edited_reads * N))
    N_unedited = N  - N_edited

    # Set up output dir
    output_dir: pathlib.Path = pathlib.Path(args.output_dir)
    os.makedirs(args.output_dir, exist_ok=True)

    # Simulate and combine
    iss_generate(args.useq, output_dir, "unedited", args.tag, N_unedited, args.seed, args.threads)
    iss_generate(args.eseq, output_dir, "edited", args.tag, N_edited, args.seed + 1, args.threads)
    combine_reads(output_dir, args.tag)
